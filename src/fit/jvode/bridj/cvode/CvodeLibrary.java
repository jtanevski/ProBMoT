package fit.jvode.bridj.cvode;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.PointerIO;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.cpp.CPPRuntime;

import fit.jvode.bridj.sundials.*;
/**
 * Wrapper for library <b>cvode</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("sundials_cvode")//,dependencies={"sundials_nvecserial"})
@Runtime(CPPRuntime.class)
public class CvodeLibrary {
	static {
		BridJ.getNativeLibraryFile("sundials_cvode");
		BridJ.register();
	}
	/// <i>native declaration : include\cvode\cvode_diag.h</i>
	public static final int CVDIAG_SUCCESS = (int)0;
	public static final int CVDIAG_MEM_NULL = (int)-1;
	public static final int CVDIAG_LMEM_NULL = (int)-2;
	public static final int CVDIAG_ILL_INPUT = (int)-3;
	public static final int CVDIAG_MEM_FAIL = (int)-4;
	public static final int CVDIAG_INV_FAIL = (int)-5;
	public static final int CVDIAG_RHSFUNC_UNRECVR = (int)-6;
	public static final int CVDIAG_RHSFUNC_RECVR = (int)-7;

	/// <i>native declaration : include\cvode\cvode_direct.h</i>
	public static final int CVDLS_SUCCESS = (int)0;
	public static final int CVDLS_MEM_NULL = (int)-1;
	public static final int CVDLS_LMEM_NULL = (int)-2;
	public static final int CVDLS_ILL_INPUT = (int)-3;
	public static final int CVDLS_MEM_FAIL = (int)-4;
	public static final int CVDLS_JACFUNC_UNRECVR = (int)-5;
	public static final int CVDLS_JACFUNC_RECVR = (int)-6;

	/// <i>native declaration : include\cvode\cvode_spils.h</i>
	public static final int CVSPILS_SUCCESS = (int)0;
	public static final int CVSPILS_MEM_NULL = (int)-1;
	public static final int CVSPILS_LMEM_NULL = (int)-2;
	public static final int CVSPILS_ILL_INPUT = (int)-3;
	public static final int CVSPILS_MEM_FAIL = (int)-4;
	public static final int CVSPILS_PMEM_NULL = (int)-5;

	public static final int CVSPILS_MAXL = (int)5;
	public static final int CVSPILS_MSBPRE = (int)50;

	/// <i>native declaration : include\cvode\cvode.h</i>
	public static final int CV_SUCCESS = (int)0;
	public static final int CV_TSTOP_RETURN = (int)1;
	public static final int CV_ROOT_RETURN = (int)2;

	public static final int CV_WARNING = (int)99;

	/// <i>native declaration : include\cvode\cvode.h</i>
	public static final int CV_TOO_MUCH_WORK = (int)-1;
	public static final int CV_TOO_MUCH_ACC = (int)-2;
	public static final int CV_ERR_FAILURE = (int)-3;
	public static final int CV_CONV_FAILURE = (int)-4;

	public static final int CV_LINIT_FAIL = (int)-5;
	public static final int CV_LSETUP_FAIL = (int)-6;
	public static final int CV_LSOLVE_FAIL = (int)-7;
	public static final int CV_RHSFUNC_FAIL = (int)-8;
	public static final int CV_FIRST_RHSFUNC_ERR = (int)-9;
	public static final int CV_REPTD_RHSFUNC_ERR = (int)-10;
	public static final int CV_UNREC_RHSFUNC_ERR = (int)-11;
	public static final int CV_RTFUNC_FAIL = (int)-12;

	/// <i>native declaration : include\cvode\cvode.h</i>
	public static final int CV_MEM_FAIL = (int)-20;
	public static final int CV_MEM_NULL = (int)-21;
	public static final int CV_ILL_INPUT = (int)-22;
	public static final int CV_NO_MALLOC = (int)-23;
	public static final int CV_BAD_K = (int)-24;
	public static final int CV_BAD_T = (int)-25;
	public static final int CV_BAD_DKY = (int)-26;
	public static final int CV_TOO_CLOSE = (int)-27;

	/// <i>native declaration : include\cvode\cvode.h</i>
	public static final int CV_NORMAL = (int)1;
	public static final int CV_ONE_STEP = (int)2;

	/// <i>native declaration : include\cvode\cvode.h</i>
	public static final int CV_FUNCTIONAL = (int)1;
	public static final int CV_NEWTON = (int)2;

	/// <i>native declaration : include\cvode\cvode.h</i>
	public static final int CV_ADAMS = (int)1;
	public static final int CV_BDF = (int)2;


	/// <i>native declaration : include\cvode\cvode.h</i>
	/**
	 * The f function which defines the right hand side of the ODE
	 * system y' = f(t,y) must have type CVRhsFn.
	 * f takes as input the independent variable value t, and the
	 * dependent variable vector y.  It stores the result of f(t,y)
	 * in the vector ydot.  The y and ydot arguments are of type
	 * N_Vector.
	 * (Allocation of memory for ydot is handled within CVODE)
	 * The user_data parameter is the same as the user_data
	 * parameter set by the user through the CVodeSetUserData routine.
	 * This user-supplied pointer is passed to the user's f function
	 * every time it is called.
	 *
	 * A CVRhsFn should return 0 if successful, a negative value if
	 * an unrecoverable error occured, and a positive value if a
	 * recoverable error (e.g. invalid y values) occured.
	 * If an unrecoverable occured, the integration is halted.
	 * If a recoverable error occured, then (in most cases) CVODE
	 * will try to correct and retry.
	 */
	public static abstract class CVRhsFn extends Callback<CVRhsFn > {
		public abstract int apply(double t, Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > ydot, Pointer<? > user_data);
	};

	/// <i>native declaration : include\cvode\cvode.h</i>
	/**
	 * A function g, which defines a set of functions g_i(t,y) whose
	 * roots are sought during the integration, must have type CVRootFn.
	 * The function g takes as input the independent variable value
	 * t, and the dependent variable vector y.  It stores the nrtfn
	 * values g_i(t,y) in the realtype array gout.
	 * (Allocation of memory for gout is handled within CVODE.)
	 * The user_data parameter is the same as that passed by the user
	 * to the CVodeSetUserData routine.  This user-supplied pointer is
	 * passed to the user's g function every time it is called.
	 *
	 * A CVRootFn should return 0 if successful or a non-zero value
	 * if an error occured (in which case the integration will be halted).
	 */
	public static abstract class CVRootFn extends Callback<CVRootFn > {
		public abstract int apply(double t, Pointer<_generic_N_Vector > y, Pointer<Double > gout, Pointer<? > user_data);
	};

	/// <i>native declaration : include\cvode\cvode.h</i>
	/**
	 * A function e, which sets the error weight vector ewt, must have
	 * type CVEwtFn.
	 * The function e takes as input the current dependent variable y.
	 * It must set the vector of error weights used in the WRMS norm:
	 *
	 *   ||y||_WRMS = sqrt [ 1/N * sum ( ewt_i * y_i)^2 ]
	 *
	 * Typically, the vector ewt has components:
	 *
	 *   ewt_i = 1 / (reltol * |y_i| + abstol_i)
	 *
	 * The user_data parameter is the same as that passed by the user
	 * to the CVodeSetUserData routine.  This user-supplied pointer is
	 * passed to the user's e function every time it is called.
	 * A CVEwtFn e must return 0 if the error weight vector has been
	 * successfuly set and a non-zero value otherwise.
	 */
	public static abstract class CVEwtFn extends Callback<CVEwtFn > {
		public abstract int apply(Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > ewt, Pointer<? > user_data);
	};

	/// <i>native declaration : include\cvode\cvode.h</i>
	/**
	 * A function eh, which handles error messages, must have type
	 * CVErrHandlerFn.
	 * The function eh takes as input the error code, the name of the
	 * module reporting the error, the error message, and a pointer to
	 * user data, the same as that passed to CVodeSetUserData.
	 *
	 * All error codes are negative, except CV_WARNING which indicates
	 * a warning (the solver continues).
	 *
	 * A CVErrHandlerFn has no return value.
	 */
	public static abstract class CVErrHandlerFn extends Callback<CVErrHandlerFn > {
		public abstract void apply(int error_code, Pointer<Byte > module, Pointer<Byte > function, Pointer<Byte > msg, Pointer<? > user_data);
	};

	/// <i>native declaration : include\cvode\cvode_direct.h</i>
	public static abstract class CVDlsDenseJacFn extends Callback<CVDlsDenseJacFn > {
		public abstract int apply(int N, double t, Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > fy, Pointer<_DlsMat > Jac, Pointer<? > user_data, Pointer<_generic_N_Vector > tmp1, Pointer<_generic_N_Vector > tmp2, Pointer<_generic_N_Vector > tmp3);
	};
	/// <i>native declaration : include\cvode\cvode_direct.h</i>
	public static abstract class CVDlsBandJacFn extends Callback<CVDlsBandJacFn > {
		public abstract int apply(int N, int mupper, int mlower, double t, Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > fy, Pointer<_DlsMat > Jac, Pointer<? > user_data, Pointer<_generic_N_Vector > tmp1, Pointer<_generic_N_Vector > tmp2, Pointer<_generic_N_Vector > tmp3);
	};
	/// <i>native declaration : include\cvode\cvode_bbdpre.h</i>
	public static abstract class CVLocalFn extends Callback<CVLocalFn > {
		public abstract int apply(int Nlocal, double t, Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > g, Pointer<? > user_data);
	};
	/// <i>native declaration : include\cvode\cvode_bbdpre.h</i>
	public static abstract class CVCommFn extends Callback<CVCommFn > {
		public abstract int apply(int Nlocal, double t, Pointer<_generic_N_Vector > y, Pointer<? > user_data);
	};
	/// <i>native declaration : include\cvode\cvode_spils.h</i>
	public static abstract class CVSpilsPrecSetupFn extends Callback<CVSpilsPrecSetupFn > {
		public abstract int apply(double t, Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > fy, int jok, Pointer<Integer > jcurPtr, double gamma, Pointer<? > user_data, Pointer<_generic_N_Vector > tmp1, Pointer<_generic_N_Vector > tmp2, Pointer<_generic_N_Vector > tmp3);
	};
	/// <i>native declaration : include\cvode\cvode_spils.h</i>
	public static abstract class CVSpilsPrecSolveFn extends Callback<CVSpilsPrecSolveFn > {
		public abstract int apply(double t, Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > fy, Pointer<_generic_N_Vector > r, Pointer<_generic_N_Vector > z, double gamma, double delta, int lr, Pointer<? > user_data, Pointer<_generic_N_Vector > tmp);
	};
	/// <i>native declaration : include\cvode\cvode_spils.h</i>
	public static abstract class CVSpilsJacTimesVecFn extends Callback<CVSpilsJacTimesVecFn > {
		public abstract int apply(Pointer<_generic_N_Vector > v, Pointer<_generic_N_Vector > Jv, double t, Pointer<_generic_N_Vector > y, Pointer<_generic_N_Vector > fy, Pointer<? > user_data, Pointer<_generic_N_Vector > tmp);
	};

	/**
	 * CVodeCreate creates an internal memory block for a problem to
	 * be solved by CVODE.
	 *
	 * lmm   is the type of linear multistep method to be used.
	 *       The legal values are CV_ADAMS and CV_BDF (see previous
	 *       description).
	 *
	 * iter  is the type of iteration used to solve the nonlinear
	 *       system that arises during each internal time step.
	 *       The legal values are CV_FUNCTIONAL and CV_NEWTON.
	 *
	 * If successful, CVodeCreate returns a pointer to initialized
	 * problem memory. This pointer should be passed to CVodeInit.
	 * If an initialization error occurs, CVodeCreate prints an error
	 * message to standard err and returns NULL.
	 */
	//TODO

	@SuppressWarnings("deprecation")
	public  static Pointer <?> CVodeCreate(int lmm, int iter) {
		return Pointer.pointerToAddress(CVodeCreate$2(lmm, iter),(PointerIO <?>)null);}
	@Ptr 
	@Name("CVodeCreate")
	public 
	native static long CVodeCreate$2(int lmm, int iter);

	/**
	* CVodeSetErrHandlerFn    | user-provided ErrHandler function.
	 *                         | [internal]
	*/
	public static native int CVodeSetErrHandlerFn(Pointer<? > cvode_mem, Pointer<CvodeLibrary.CVErrHandlerFn > ehfun, Pointer<? > eh_data);

	/**
	 * CVodeSetErrFile         | the file pointer for an error file
	 *                         | where all CVODE warning and error
	 *                         | messages will be written if the default
	 *                         | internal error handling function is used.
	 *                         | This parameter can be stdout (standard
	 *                         | output), stderr (standard error), or a
	 *                         | file pointer (corresponding to a user
	 *                         | error file opened for writing) returned
	 *                         | by fopen.
	 *                         | If not called, then all messages will
	 *                         | be written to the standard error stream.
	 *                         | [stderr]
	*/
	public static native int CVodeSetErrFile(Pointer<? > cvode_mem, Pointer<CvodeLibrary.FILE > errfp);

	/**
	 * CVodeSetUserData        | a pointer to user data that will be
	 *                         | passed to the user's f function every
	 *                         | time f is called.
	 *                         | [NULL]
	*/
	public static native int CVodeSetUserData(Pointer<? > cvode_mem, Pointer<? > user_data);

	/**
	 * CVodeSetMaxOrd          | maximum lmm order to be used by the
	 *                         | solver.
	 *                         | [12 for Adams , 5 for BDF]
	*/
	public static native int CVodeSetMaxOrd(Pointer<? > cvode_mem, int maxord);

	/**
	 * CVodeSetMaxNumSteps     | maximum number of internal steps to be
	 *                         | taken by the solver in its attempt to
	 *                         | reach tout.
	 *                         | [500]
	*/
	public static native int CVodeSetMaxNumSteps(Pointer<? > cvode_mem, int mxsteps);

	/**
	 * CVodeSetMaxHnilWarns    | maximum number of warning messages
	 *                         | issued by the solver that t+h==t on the
	 *                         | next internal step. A value of -1 means
	 *                         | no such messages are issued.
	 *                         | [10]
	*/
	public static native int CVodeSetMaxHnilWarns(Pointer<? > cvode_mem, int mxhnil);

	/**
	 * CVodeSetStabLimDet      | flag to turn on/off stability limit
	 *                         | detection (TRUE = on, FALSE = off).
	 *                         | When BDF is used and order is 3 or
	 *                         | greater, CVsldet is called to detect
	 *                         | stability limit.  If limit is detected,
	 *                         | the order is reduced.
	 *                         | [FALSE]
	*/
	public static native int CVodeSetStabLimDet(Pointer<? > cvode_mem, int stldet);

	/**
	 * CVodeSetInitStep        | initial step size.
	 *                         | [estimated by CVODE]
	*/
	public static native int CVodeSetInitStep(Pointer<? > cvode_mem, double hin);

	/**
	 * CVodeSetMinStep         | minimum absolute value of step size
	 *                         | allowed.
	 *                         | [0.0]
	*/
	public static native int CVodeSetMinStep(Pointer<? > cvode_mem, double hmin);

	/**
	 * CVodeSetMaxStep         | maximum absolute value of step size
	 *                         | allowed.
	 *                         | [infinity]
	*/
	public static native int CVodeSetMaxStep(Pointer<? > cvode_mem, double hmax);

	/**
	 * CVodeSetStopTime        | the independent variable value past
	 *                         | which the solution is not to proceed.
	 *                         | [infinity]
	*/
	public static native int CVodeSetStopTime(Pointer<? > cvode_mem, double tstop);

	/**
	 * CVodeSetMaxErrTestFails | Maximum number of error test failures
	 *                         | in attempting one step.
	 *                         | [7]
	*/
	public static native int CVodeSetMaxErrTestFails(Pointer<? > cvode_mem, int maxnef);

	/**
	 * CVodeSetMaxNonlinIters  | Maximum number of nonlinear solver
	 *                         | iterations at one solution.
	 *                         | [3]
	*/
	public static native int CVodeSetMaxNonlinIters(Pointer<? > cvode_mem, int maxcor);

	/**
	 * CVodeSetMaxConvFails    | Maximum number of convergence failures
	 *                         | allowed in attempting one step.
	 *                         | [10]
	*/
	public static native int CVodeSetMaxConvFails(Pointer<? > cvode_mem, int maxncf);

	/**
	 * CVodeSetNonlinConvCoef  | Coefficient in the nonlinear
	 *                         | convergence test.
	 *                         | [0.1]
	*/
	public static native int CVodeSetNonlinConvCoef(Pointer<? > cvode_mem, double nlscoef);

	/**
	 * CVodeSetIterType        | Changes the current nonlinear iteration
	 *                         | type.
	 *                         | [set by CVodecreate]
	*/
	public static native int CVodeSetIterType(Pointer<? > cvode_mem, int iter);

	/**
	 * CVodeSetRootDirection      | Specifies the direction of zero
	 *                            | crossings to be monitored
	 *                            | [both directions]
	*/
	public static native int CVodeSetRootDirection(Pointer<? > cvode_mem, Pointer<Integer > rootdir);

	/**
	 * CVodeSetNoInactiveRootWarn | disable warning about possible
	 *                            | g==0 at beginning of integration
	*/
	public static native int CVodeSetNoInactiveRootWarn(Pointer<? > cvode_mem);




	/**
	 * CVodeInit allocates and initializes memory for a problem to
	 * to be solved by CVODE.
	 *
	 * cvode_mem is pointer to CVODE memory returned by CVodeCreate.
	 *
	 * f       is the name of the C function defining the right-hand
	 *         side function in y' = f(t,y).
	 *
	 * t0      is the initial value of t.
	 *
	 * y0      is the initial condition vector y(t0).
	 *
	 * Return flag:
	 *  CV_SUCCESS if successful
	 *  CV_MEM_NULL if the cvode memory was NULL
	 *  CV_MEM_FAIL if a memory allocation failed
	 *  CV_ILL_INPUT f an argument has an illegal value.
	 */
	public static int CVodeInit(Pointer<? > cvode_mem, Pointer<CvodeLibrary.CVRhsFn > f, double t0,  Pointer<_generic_N_Vector > y0) {
		return CVodeInit(Pointer.getPeer(cvode_mem), Pointer.getPeer(f), t0, Pointer.getPeer(y0));
	}
	public native static int CVodeInit(@Ptr long cvode_mem, @Ptr long f, double t0, @Ptr long y0);
	
	/**
	 * CVodeReInit re-initializes CVode for the solution of a problem,
	 * where a prior call to CVodeInit has been made with the same
	 * problem size N. CVodeReInit performs the same input checking
	 * and initializations that CVodeInit does.
	 * But it does no memory allocation, assuming that the existing
	 * internal memory is sufficient for the new problem.
	 *
	 * The use of CVodeReInit requires that the maximum method order,
	 * maxord, is no larger for the new problem than for the problem
	 * specified in the last call to CVodeInit.  This condition is
	 * automatically fulfilled if the multistep method parameter lmm
	 * is unchanged (or changed from CV_ADAMS to CV_BDF) and the default
	 * value for maxord is specified.
	 *
	 * All of the arguments to CVodeReInit have names and meanings
	 * identical to those of CVodeInit.
	 *
	 * The return value of CVodeReInit is equal to CV_SUCCESS = 0 if
	 * there were no errors; otherwise it is a negative int equal to:
	 *   CV_MEM_NULL      indicating cvode_mem was NULL (i.e.,
	 *                    CVodeCreate has not been called).
	 *   CV_NO_MALLOC     indicating that cvode_mem has not been
	 *                    allocated (i.e., CVodeInit has not been
	 *                    called).
	 *   CV_ILL_INPUT     indicating an input argument was illegal
	 *                    (including an attempt to increase maxord).
	 * In case of an error return, an error message is also printed.
	 */
	//public static native int CVodeReInit(Pointer<? > cvode_mem, double t0,  y0);

	public static int CVodeReInit(Pointer<? > cvode_mem, double t0, Pointer<_generic_N_Vector > y0) {
		return CVodeReInit(Pointer.getPeer(cvode_mem), t0, Pointer.getPeer(y0));
	}
	
	public native static int CVodeReInit(@Ptr long cvode_mem, double t0, @Ptr long y0);
	
	
	/**
	 * These functions specify the integration tolerances. One of them
	 * MUST be called before the first call to CVode.
	 *
	 * CVodeSStolerances specifies scalar relative and absolute tolerances.
	 * CVodeSVtolerances specifies scalar relative tolerance and a vector
	 *   absolute tolerance (a potentially different absolute tolerance
	 *   for each vector component).
	 * CVodeWFtolerances specifies a user-provides function (of type CVEwtFn)
	 *   which will be called to set the error weight vector.
	 *
	 * The tolerances reltol and abstol define a vector of error weights,
	 * ewt, with components
	 *   ewt[i] = 1/(reltol*abs(y[i]) + abstol)      (in the SS case), or
	 *   ewt[i] = 1/(reltol*abs(y[i]) + abstol[i])   (in the SV case).
	 * This vector is used in all error and convergence tests, which
	 * use a weighted RMS norm on all error-like vectors v:
	 *    WRMSnorm(v) = sqrt( (1/N) sum(i=1..N) (v[i]*ewt[i])^2 ),
	 * where N is the problem dimension.
	 *
	 * The return value of these functions is equal to CV_SUCCESS = 0 if
	 * there were no errors; otherwise it is a negative int equal to:
	 *   CV_MEM_NULL      indicating cvode_mem was NULL (i.e.,
	 *                    CVodeCreate has not been called).
	 *   CV_NO_MALLOC     indicating that cvode_mem has not been
	 *                    allocated (i.e., CVodeInit has not been
	 *                    called).
	 *   CV_ILL_INPUT     indicating an input argument was illegal
	 *                    (e.g. a negative tolerance)
	 * In case of an error return, an error message is also printed.
	 */
	public static native int CVodeSStolerances(Pointer<? > cvode_mem, double reltol, double abstol);

	/**
	 * These functions specify the integration tolerances. One of them
	 * MUST be called before the first call to CVode.
	 *
	 * CVodeSStolerances specifies scalar relative and absolute tolerances.
	 * CVodeSVtolerances specifies scalar relative tolerance and a vector
	 *   absolute tolerance (a potentially different absolute tolerance
	 *   for each vector component).
	 * CVodeWFtolerances specifies a user-provides function (of type CVEwtFn)
	 *   which will be called to set the error weight vector.
	 *
	 * The tolerances reltol and abstol define a vector of error weights,
	 * ewt, with components
	 *   ewt[i] = 1/(reltol*abs(y[i]) + abstol)      (in the SS case), or
	 *   ewt[i] = 1/(reltol*abs(y[i]) + abstol[i])   (in the SV case).
	 * This vector is used in all error and convergence tests, which
	 * use a weighted RMS norm on all error-like vectors v:
	 *    WRMSnorm(v) = sqrt( (1/N) sum(i=1..N) (v[i]*ewt[i])^2 ),
	 * where N is the problem dimension.
	 *
	 * The return value of these functions is equal to CV_SUCCESS = 0 if
	 * there were no errors; otherwise it is a negative int equal to:
	 *   CV_MEM_NULL      indicating cvode_mem was NULL (i.e.,
	 *                    CVodeCreate has not been called).
	 *   CV_NO_MALLOC     indicating that cvode_mem has not been
	 *                    allocated (i.e., CVodeInit has not been
	 *                    called).
	 *   CV_ILL_INPUT     indicating an input argument was illegal
	 *                    (e.g. a negative tolerance)
	 * In case of an error return, an error message is also printed.
	 */
	public static native int CVodeSVtolerances(Pointer<? > cvode_mem, double reltol, Pointer<_generic_N_Vector > abstol);

	/**
	 * These functions specify the integration tolerances. One of them
	 * MUST be called before the first call to CVode.
	 *
	 * CVodeSStolerances specifies scalar relative and absolute tolerances.
	 * CVodeSVtolerances specifies scalar relative tolerance and a vector
	 *   absolute tolerance (a potentially different absolute tolerance
	 *   for each vector component).
	 * CVodeWFtolerances specifies a user-provides function (of type CVEwtFn)
	 *   which will be called to set the error weight vector.
	 *
	 * The tolerances reltol and abstol define a vector of error weights,
	 * ewt, with components
	 *   ewt[i] = 1/(reltol*abs(y[i]) + abstol)      (in the SS case), or
	 *   ewt[i] = 1/(reltol*abs(y[i]) + abstol[i])   (in the SV case).
	 * This vector is used in all error and convergence tests, which
	 * use a weighted RMS norm on all error-like vectors v:
	 *    WRMSnorm(v) = sqrt( (1/N) sum(i=1..N) (v[i]*ewt[i])^2 ),
	 * where N is the problem dimension.
	 *
	 * The return value of these functions is equal to CV_SUCCESS = 0 if
	 * there were no errors; otherwise it is a negative int equal to:
	 *   CV_MEM_NULL      indicating cvode_mem was NULL (i.e.,
	 *                    CVodeCreate has not been called).
	 *   CV_NO_MALLOC     indicating that cvode_mem has not been
	 *                    allocated (i.e., CVodeInit has not been
	 *                    called).
	 *   CV_ILL_INPUT     indicating an input argument was illegal
	 *                    (e.g. a negative tolerance)
	 * In case of an error return, an error message is also printed.
	 */
	public static native int CVodeWFtolerances(Pointer<? > cvode_mem, Pointer<CvodeLibrary.CVEwtFn > efun);

	/**
	 * CVodeRootInit initializes a rootfinding problem to be solved
	 * during the integration of the ODE system.  It must be called
	 * after CVodeCreate, and before CVode.  The arguments are:
	 *
	 * cvode_mem = pointer to CVODE memory returned by CVodeCreate.
	 *
	 * nrtfn     = number of functions g_i, an int >= 0.
	 *
	 * g         = name of user-supplied function, of type CVRootFn,
	 *             defining the functions g_i whose roots are sought.
	 *
	 * If a new problem is to be solved with a call to CVodeReInit,
	 * where the new problem has no root functions but the prior one
	 * did, then call CVodeRootInit with nrtfn = 0.
	 *
	 * The return value of CVodeRootInit is CV_SUCCESS = 0 if there were
	 * no errors; otherwise it is a negative int equal to:
	 *   CV_MEM_NULL     indicating cvode_mem was NULL, or
	 *   CV_MEM_FAIL     indicating a memory allocation failed.
	 *                    (including an attempt to increase maxord).
	 *   CV_ILL_INPUT   indicating nrtfn > 0 but g = NULL.
	 * In case of an error return, an error message is also printed.
	 */
	public static native int CVodeRootInit(Pointer<? > cvode_mem, int nrtfn, Pointer<CvodeLibrary.CVRootFn > g);

	/**
	 * CVode integrates the ODE over an interval in t.
	 * If itask is CV_NORMAL, then the solver integrates from its
	 * current internal t value to a point at or beyond tout, then
	 * interpolates to t = tout and returns y(tout) in the user-
	 * allocated vector yout. If itask is CV_ONE_STEP, then the solver
	 * takes one internal time step and returns in yout the value of
	 * y at the new internal time. In this case, tout is used only
	 * during the first call to CVode to determine the direction of
	 * integration and the rough scale of the t variable. If tstop is
	 * enabled (through a call to CVodeSetStopTime), then CVode returns
	 * the solution at tstop. Once the integrator returns at a tstop
	 * time, any future testing for tstop is disabled (and can be
	 * reenabled only though a new call to CVodeSetStopTime).
	 * The time reached by the solver is placed in (*tret). The
	 * user is responsible for allocating the memory for this value.
	 *
	 * cvode_mem is the pointer to CVODE memory returned by
	 *           CVodeCreate.
	 *
	 * tout  is the next time at which a computed solution is desired.
	 *
	 * yout  is the computed solution vector. In CV_NORMAL mode with no
	 *       errors and no roots found, yout=y(tout).
	 *
	 * tret  is a pointer to a real location. CVode sets (*tret) to
	 *       the time reached by the solver and returns
	 *       yout=y(*tret).
	 *
	 * itask is CV_NORMAL or CV_ONE_STEP. These two modes are described above.
	 *
	 * Here is a brief description of each return value:
	 *
	 * CV_SUCCESS:      CVode succeeded and no roots were found.
	 *
	 * CV_ROOT_RETURN:  CVode succeeded, and found one or more roots.
	 *                  If nrtfn > 1, call CVodeGetRootInfo to see
	 *                  which g_i were found to have a root at (*tret).
	 *
	 * CV_TSTOP_RETURN: CVode succeeded and returned at tstop.
	 *
	 * CV_MEM_NULL:     The cvode_mem argument was NULL.
	 *
	 * CV_NO_MALLOC:    cvode_mem was not allocated.
	 *
	 * CV_ILL_INPUT:    One of the inputs to CVode is illegal. This
	 *                  includes the situation when a component of the
	 *                  error weight vectors becomes < 0 during
	 *                  internal time-stepping.  It also includes the
	 *                  situation where a root of one of the root
	 *                  functions was found both at t0 and very near t0.
	 *                  The ILL_INPUT flag will also be returned if the
	 *                  linear solver routine CV--- (called by the user
	 *                  after calling CVodeCreate) failed to set one of
	 *                  the linear solver-related fields in cvode_mem or
	 *                  if the linear solver's init routine failed. In
	 *                  any case, the user should see the printed
	 *                  error message for more details.
	 *
	 * CV_TOO_MUCH_WORK: The solver took mxstep internal steps but
	 *                  could not reach tout. The default value for
	 *                  mxstep is MXSTEP_DEFAULT = 500.
	 *
	 * CV_TOO_MUCH_ACC: The solver could not satisfy the accuracy
	 *                  demanded by the user for some internal step.
	 *
	 * CV_ERR_FAILURE:  Error test failures occurred too many times
	 *                  (= MXNEF = 7) during one internal time step or
	 *                  occurred with |h| = hmin.
	 *
	 * CV_CONV_FAILURE: Convergence test failures occurred too many
	 *                  times (= MXNCF = 10) during one internal time
	 *                  step or occurred with |h| = hmin.
	 *
	 * CV_LINIT_FAIL:   The linear solver's initialization function
	 *                  failed.
	 *
	 * CV_LSETUP_FAIL:  The linear solver's setup routine failed in an
	 *                  unrecoverable manner.
	 *
	 * CV_LSOLVE_FAIL:  The linear solver's solve routine failed in an
	 *                  unrecoverable manner.
	 */
	public static  int CVode(Pointer<? > cvode_mem, double tout, Pointer<_generic_N_Vector > yout, Pointer<Double > tret, int itask)
	{
		return CVode(Pointer.getPeer(cvode_mem), tout, Pointer.getPeer(yout), Pointer.getPeer(tret), itask);
	}
	
	protected native static  int CVode (@Ptr long cvode_mem, double tout, @Ptr long yout, @Ptr long tret , int itask);

	/**
	 * CVodeGetDky computes the kth derivative of the y function at
	 * time t, where tn-hu <= t <= tn, tn denotes the current
	 * internal time reached, and hu is the last internal step size
	 * successfully used by the solver. The user may request
	 * k=0, 1, ..., qu, where qu is the order last used. The
	 * derivative vector is returned in dky. This vector must be
	 * allocated by the caller. It is only legal to call this
	 * function after a successful return from CVode.
	 *
	 * cvode_mem is the pointer to CVODE memory returned by
	 *           CVodeCreate.
	 *
	 * t   is the time at which the kth derivative of y is evaluated.
	 *     The legal range for t is [tn-hu,tn] as described above.
	 *
	 * k   is the order of the derivative of y to be computed. The
	 *     legal range for k is [0,qu] as described above.
	 *
	 * dky is the output derivative vector [((d/dy)^k)y](t).
	 *
	 * The return value for CVodeGetDky is one of:
	 *
	 *   CV_SUCCESS:  CVodeGetDky succeeded.
	 *
	 *   CV_BAD_K:    k is not in the range 0, 1, ..., qu.
	 *
	 *   CV_BAD_T:    t is not in the interval [tn-hu,tn].
	 *
	 *   CV_BAD_DKY:  The dky argument was NULL.
	 *
	 *   CV_MEM_NULL: The cvode_mem argument was NULL.
	 */
	public static native int CVodeGetDky(Pointer<? > cvode_mem, double t, int k, Pointer<_generic_N_Vector > dky);

	/**
	 * CVodeGetWorkSpace returns the CVODE real and integer workspaces
	*/
	public static native int CVodeGetWorkSpace(Pointer<? > cvode_mem, Pointer<Integer > lenrw, Pointer<Integer > leniw);

	/**
	 * CVodeGetNumSteps returns the cumulative number of internal
	 *                  steps taken by the solver
	*/
	public static native int CVodeGetNumSteps(Pointer<? > cvode_mem, Pointer<Integer > nsteps);

	/**
	 * CVodeGetNumRhsEvals returns the number of calls to the user's
	 *                     f function
	*/
	public static native int CVodeGetNumRhsEvals(Pointer<? > cvode_mem, Pointer<Integer > nfevals);

	/**
	 * CVodeGetNumLinSolvSetups returns the number of calls made to
	 *                          the linear solver's setup routine
	*/
	public static native int CVodeGetNumLinSolvSetups(Pointer<? > cvode_mem, Pointer<Integer > nlinsetups);

	/**
	 * CVodeGetNumErrTestFails returns the number of local error test
	 *                         failures that have occured
	*/
	public static native int CVodeGetNumErrTestFails(Pointer<? > cvode_mem, Pointer<Integer > netfails);

	/**
	 * CVodeGetLastOrder returns the order used during the last
	 *                   internal step
	*/
	public static native int CVodeGetLastOrder(Pointer<? > cvode_mem, Pointer<Integer > qlast);

	/**
	 * CVodeGetCurrentOrder returns the order to be used on the next
	 *                      internal step
	*/
	public static native int CVodeGetCurrentOrder(Pointer<? > cvode_mem, Pointer<Integer > qcur);

	/**
	 * CVodeGetNumStabLimOrderReds returns the number of order
	 *                             reductions due to stability limit
	 *                             detection
	*/
	public static native int CVodeGetNumStabLimOrderReds(Pointer<? > cvode_mem, Pointer<Integer > nslred);

	/**
	 * CVodeGetActualInitStep returns the actual initial step size
	 *                        used by CVODE
	*/
	public static native int CVodeGetActualInitStep(Pointer<? > cvode_mem, Pointer<Double > hinused);

	/**
	 * CVodeGetLastStep returns the step size for the last internal
	 *                  step
	*/
	public static native int CVodeGetLastStep(Pointer<? > cvode_mem, Pointer<Double > hlast);

	/**
	 * CVodeGetCurrentStep returns the step size to be attempted on
	 *                     the next internal step
	*/
	public static native int CVodeGetCurrentStep(Pointer<? > cvode_mem, Pointer<Double > hcur);

	/**
	 * CVodeGetCurrentTime returns the current internal time reached
	 *                     by the solver
	*/
	public static native int CVodeGetCurrentTime(Pointer<? > cvode_mem, Pointer<Double > tcur);

	/**
	 * CVodeGetTolScaleFactor returns a suggested factor by which the
	 *                        user's tolerances should be scaled when
	 *                        too much accuracy has been requested for
	 *                        some internal step
	*/
	public static native int CVodeGetTolScaleFactor(Pointer<? > cvode_mem, Pointer<Double > tolsfac);

	/**
	 * CVodeGetErrWeights returns the current error weight vector.
	 *                    The user must allocate space for eweight.
	*/
	public static native int CVodeGetErrWeights(Pointer<? > cvode_mem, Pointer<_generic_N_Vector > eweight);

	/**
	 * CVodeGetEstLocalErrors returns the vector of estimated local
	 *                        errors. The user must allocate space
	 *                        for ele.
	*/
	public static native int CVodeGetEstLocalErrors(Pointer<? > cvode_mem, Pointer<_generic_N_Vector > ele);

	/**
	 * CVodeGetNumGEvals returns the number of calls to the user's
	 *                   g function (for rootfinding)
	*/
	public static native int CVodeGetNumGEvals(Pointer<? > cvode_mem, Pointer<Integer > ngevals);

	/**
	 * CVodeGetRootInfo returns the indices for which g_i was found to
	 *                  have a root. The user must allocate space for
	 *                  rootsfound. For i = 0 ... nrtfn-1,
	 *                  rootsfound[i] = 1 if g_i has a root, and = 0 if not.
	*/
	public static native int CVodeGetRootInfo(Pointer<? > cvode_mem, Pointer<Integer > rootsfound);

	/**
	 * As a convenience, the following functions provides the
	 * optional outputs in one group.
	 */
	public static native int CVodeGetIntegratorStats(Pointer<? > cvode_mem, Pointer<Integer > nsteps, Pointer<Integer > nfevals, Pointer<Integer > nlinsetups, Pointer<Integer > netfails, Pointer<Integer > qlast, Pointer<Integer > qcur, Pointer<Double > hinused, Pointer<Double > hlast, Pointer<Double > hcur, Pointer<Double > tcur);

	/**
	 * CVodeGetNumNonlinSolvIters returns the number of nonlinear
	 *                            solver iterations performed.
	 */
	public static native int CVodeGetNumNonlinSolvIters(Pointer<? > cvode_mem, Pointer<Integer > nniters);

	/**
	 * CVodeGetNumNonlinSolvConvFails returns the number of nonlinear
	 *                                convergence failures.
	 */
	public static native int CVodeGetNumNonlinSolvConvFails(Pointer<? > cvode_mem, Pointer<Integer > nncfails);

	/**
	 * As a convenience, the following function provides the
	 * nonlinear solver optional outputs in a group.
	 */
	public static native int CVodeGetNonlinSolvStats(Pointer<? > cvode_mem, Pointer<Integer > nniters, Pointer<Integer > nncfails);

	/**
	 * The following function returns the name of the constant
	 * associated with a CVODE return flag
	 */
	public static native Pointer<Byte > CVodeGetReturnFlagName(int flag);

	/**
	 * CVodeFree frees the problem memory cvode_mem allocated by
	 * CVodeCreate and CVodeInit. Its only argument is the pointer
	 * cvode_mem returned by CVodeCreate.
	 */
	public static void CVodeFree(Pointer<Pointer<? > > cvode_mem) {
		CVodeFree(Pointer.getPeer(cvode_mem));
	}
	public native static void CVodeFree(@Ptr long cvode_mem);

	public static native int CVDlsSetDenseJacFn(Pointer<? > cvode_mem, Pointer<CvodeLibrary.CVDlsDenseJacFn > jac);
	public static native int CVDlsSetBandJacFn(Pointer<? > cvode_mem, Pointer<CvodeLibrary.CVDlsBandJacFn > jac);
	public static native int CVDlsGetWorkSpace(Pointer<? > cvode_mem, Pointer<Integer > lenrwLS, Pointer<Integer > leniwLS);
	public static native int CVDlsGetNumJacEvals(Pointer<? > cvode_mem, Pointer<Integer > njevals);
	public static native int CVDlsGetNumRhsEvals(Pointer<? > cvode_mem, Pointer<Integer > nfevalsLS);
	public static native int CVDlsGetLastFlag(Pointer<? > cvode_mem, Pointer<Integer > flag);
	public static native Pointer<Byte > CVDlsGetReturnFlagName(int flag);

	/**
 * A call to the CVBand function links the main CVODE integrator
 * with the CVBAND linear solver.
 *
 * cvode_mem is the pointer to the integrator memory returned by
 *           CVodeCreate.
 *
 * N is the size of the ODE system.
 *
 * mupper is the upper bandwidth of the band Jacobian
 *        approximation.
 *
 * mlower is the lower bandwidth of the band Jacobian
 *        approximation.
 *
 * The return value of CVBand is one of:
 *    CVDLS_SUCCESS   if successful
 *    CVDLS_MEM_NULL  if the cvode memory was NULL
 *    CVDLS_MEM_FAIL  if there was a memory allocation failure
 *    CVDLS_ILL_INPUT if a required vector operation is missing or
 *                       if a bandwidth has an illegal value.

	 * This routine initializes the memory record and sets various function
	 * fields specific to the band linear solver module.  CVBand first calls
	 * the existing lfree routine if this is not NULL.  It then sets the
	 * cv_linit, cv_lsetup, cv_lsolve, and cv_lfree fields in (*cvode_mem)
	 * to be cvBandInit, cvBandSetup, cvBandSolve, and cvBandFree,
	 * respectively.  It allocates memory for a structure of type
	 * CVDlsMemRec and sets the cv_lmem field in (*cvode_mem) to the
	 * address of this structure.  It sets setupNonNull in (*cvode_mem) to be
	 * TRUE, d_mu to be mupper, d_ml to be mlower, and the d_jac field to be
	 * cvDlsBandDQJac.
	 * Finally, it allocates memory for M, savedJ, and pivot.  The CVBand
	 * return value is SUCCESS = 0, LMEM_FAIL = -1, or LIN_ILL_INPUT = -2.
	 *
	 * NOTE: The band linear solver assumes a serial implementation
	 *       of the NVECTOR package. Therefore, CVBand will first
	 *       test for compatible a compatible N_Vector internal
	 *       representation by checking that the function
	 *       N_VGetArrayPointer exists.
	 */
	public static native int CVBand(Pointer<? > cvode_mem, int N, int mupper, int mlower);
	public static native int CVBandPrecInit(Pointer<? > cvode_mem, int N, int mu, int ml);
	public static native int CVBandPrecGetWorkSpace(Pointer<? > cvode_mem, Pointer<Integer > lenrwLS, Pointer<Integer > leniwLS);
	public static native int CVBandPrecGetNumRhsEvals(Pointer<? > cvode_mem, Pointer<Integer > nfevalsBP);
	public static native int CVBBDPrecInit(Pointer<? > cvode_mem, int Nlocal, int mudq, int mldq, int mukeep, int mlkeep, double dqrely, Pointer<CvodeLibrary.CVLocalFn > gloc, Pointer<CvodeLibrary.CVCommFn > cfn);
	public static native int CVBBDPrecReInit(Pointer<? > cvode_mem, int mudq, int mldq, double dqrely);
	public static native int CVBBDPrecGetWorkSpace(Pointer<? > cvode_mem, Pointer<Integer > lenrwLS, Pointer<Integer > leniwLS);
	public static native int CVBBDPrecGetNumGfnEvals(Pointer<? > cvode_mem, Pointer<Integer > ngevalsBBDP);

	/**
 * A call to the CVDense function links the main integrator with
 * the CVDENSE linear solver.
 *
 * cvode_mem is the pointer to the integrator memory returned by
 *           CVodeCreate.
 *
 * N is the size of the ODE system.
 *
 * The return value of CVDense is one of:
 *    CVDLS_SUCCESS   if successful
 *    CVDLS_MEM_NULL  if the cvode memory was NULL
 *    CVDLS_MEM_FAIL  if there was a memory allocation failure
 *    CVDLS_ILL_INPUT if a required vector operation is missing

	 * This routine initializes the memory record and sets various function
	 * fields specific to the dense linear solver module.  CVDense first
	 * calls the existing lfree routine if this is not NULL.  Then it sets
	 * the cv_linit, cv_lsetup, cv_lsolve, cv_lfree fields in (*cvode_mem)
	 * to be cvDenseInit, cvDenseSetup, cvDenseSolve, and cvDenseFree,
	 * respectively.  It allocates memory for a structure of type
	 * CVDlsMemRec and sets the cv_lmem field in (*cvode_mem) to the
	 * address of this structure.  It sets setupNonNull in (*cvode_mem) to
	 * TRUE, and the d_jac field to the default cvDlsDenseDQJac.
	 * Finally, it allocates memory for M, savedJ, and pivots.
	 * The return value is SUCCESS = 0, or LMEM_FAIL = -1.
	 *
	 * NOTE: The dense linear solver assumes a serial implementation
	 *       of the NVECTOR package. Therefore, CVDense will first
	 *       test for compatible a compatible N_Vector internal
	 *       representation by checking that N_VGetArrayPointer and
	 *       N_VSetArrayPointer exist.
	 */
	public static native int CVDense(Pointer<? > cvode_mem, int N);

	/**
	 * A call to the CVDiag function links the main integrator with
	 * the CVDIAG linear solver.
	 *
	 * cvode_mem is the pointer to the integrator memory returned by
	 *           CVodeCreate.
	 *
	 * The return value of CVDiag is one of:
	 *    CVDIAG_SUCCESS   if successful
	 *    CVDIAG_MEM_NULL  if the cvode memory was NULL
	 *    CVDIAG_MEM_FAIL  if there was a memory allocation failure
	 *    CVDIAG_ILL_INPUT if a required vector operation is missing

 * This routine initializes the memory record and sets various function
 * fields specific to the diagonal linear solver module.  CVDense first
 * calls the existing lfree routine if this is not NULL.  Then it sets
 * the cv_linit, cv_lsetup, cv_lsolve, cv_lfree fields in (*cvode_mem)
 * to be CVDiagInit, CVDiagSetup, CVDiagSolve, and CVDiagFree,
 * respectively.  It allocates memory for a structure of type
 * CVDiagMemRec and sets the cv_lmem field in (*cvode_mem) to the
 * address of this structure.  It sets setupNonNull in (*cvode_mem) to
 * TRUE.  Finally, it allocates memory for M, bit, and bitcomp.
 * The CVDiag return value is SUCCESS = 0, LMEM_FAIL = -1, or
 * LIN_ILL_INPUT=-2.

	 */
	public static native int CVDiag(Pointer<? > cvode_mem);
	public static native int CVDiagGetWorkSpace(Pointer<? > cvode_mem, Pointer<Integer > lenrwLS, Pointer<Integer > leniwLS);
	public static native int CVDiagGetNumRhsEvals(Pointer<? > cvode_mem, Pointer<Integer > nfevalsLS);
	public static native int CVDiagGetLastFlag(Pointer<? > cvode_mem, Pointer<Integer > flag);
	public static native Pointer<Byte > CVDiagGetReturnFlagName(int flag);

//	public static native int CVLapackDense(Pointer<? > cvode_mem, int N);
//	public static native int CVLapackBand(Pointer<? > cvode_mem, int N, int mupper, int mlower);

	public static native int CVSpilsSetPrecType(Pointer<? > cvode_mem, int pretype);
	public static native int CVSpilsSetGSType(Pointer<? > cvode_mem, int gstype);
	public static native int CVSpilsSetMaxl(Pointer<? > cvode_mem, int maxl);
	public static native int CVSpilsSetEpsLin(Pointer<? > cvode_mem, double eplifac);
	public static native int CVSpilsSetPreconditioner(Pointer<? > cvode_mem, Pointer<CvodeLibrary.CVSpilsPrecSetupFn > pset, Pointer<CvodeLibrary.CVSpilsPrecSolveFn > psolve);
	public static native int CVSpilsSetJacTimesVecFn(Pointer<? > cvode_mem, Pointer<CvodeLibrary.CVSpilsJacTimesVecFn > jtv);
	public static native int CVSpilsGetWorkSpace(Pointer<? > cvode_mem, Pointer<Integer > lenrwLS, Pointer<Integer > leniwLS);
	public static native int CVSpilsGetNumPrecEvals(Pointer<? > cvode_mem, Pointer<Integer > npevals);
	public static native int CVSpilsGetNumPrecSolves(Pointer<? > cvode_mem, Pointer<Integer > npsolves);
	public static native int CVSpilsGetNumLinIters(Pointer<? > cvode_mem, Pointer<Integer > nliters);
	public static native int CVSpilsGetNumConvFails(Pointer<? > cvode_mem, Pointer<Integer > nlcfails);
	public static native int CVSpilsGetNumJtimesEvals(Pointer<? > cvode_mem, Pointer<Integer > njvevals);
	public static native int CVSpilsGetNumRhsEvals(Pointer<? > cvode_mem, Pointer<Integer > nfevalsLS);
	public static native int CVSpilsGetLastFlag(Pointer<? > cvode_mem, Pointer<Integer > flag);
	public static native Pointer<Byte > CVSpilsGetReturnFlagName(int flag);


	/**
	 * A call to the CVSpbcg function links the main CVODE integrator
	 * with the CVSPBCG linear solver.
	 *
	 * cvode_mem is the pointer to the integrator memory returned by
	 *           CVodeCreate.
	 *
	 * pretype   is the type of user preconditioning to be done.
	 *           This must be one of the four enumeration constants
	 *           PREC_NONE, PREC_LEFT, PREC_RIGHT, or PREC_BOTH defined
	 *           in iterative.h. These correspond to no preconditioning,
	 *           left preconditioning only, right preconditioning
	 *           only, and both left and right preconditioning,
	 *           respectively.
	 *
	 * maxl      is the maximum Krylov dimension. This is an
	 *           optional input to the CVSPBCG solver. Pass 0 to
	 *           use the default value CVSPBCG_MAXL=5.
	 *
	 * The return value of CVSpbcg is one of:
	 *    CVSPILS_SUCCESS   if successful
	 *    CVSPILS_MEM_NULL  if the cvode memory was NULL
	 *    CVSPILS_MEM_FAIL  if there was a memory allocation failure
	 *    CVSPILS_ILL_INPUT if a required vector operation is missing
	 * The above constants are defined in cvode_spils.h
	 *
 * This routine initializes the memory record and sets various function
 * fields specific to the Spbcg linear solver module. CVSpbcg first
 * calls the existing lfree routine if this is not NULL. It then sets
 * the cv_linit, cv_lsetup, cv_lsolve, cv_lfree fields in (*cvode_mem)
 * to be CVSpbcgInit, CVSpbcgSetup, CVSpbcgSolve, and CVSpbcgFree,
 * respectively. It allocates memory for a structure of type
 * CVSpilsMemRec and sets the cv_lmem field in (*cvode_mem) to the
 * address of this structure. It sets setupNonNull in (*cvode_mem),
 * and sets various fields in the CVSpilsMemRec structure.
 * Finally, CVSpbcg allocates memory for ytemp and x, and calls
 * SpbcgMalloc to allocate memory for the Spbcg solver.
 	 */
	public static native int CVSpbcg(Pointer<? > cvode_mem, int pretype, int maxl);

	/**
	 * A call to the CVSpgmr function links the main CVODE integrator
	 * with the CVSPGMR linear solver.
	 *
	 * cvode_mem is the pointer to the integrator memory returned by
	 *           CVodeCreate.
	 *
	 * pretype   is the type of user preconditioning to be done.
	 *           This must be one of the four enumeration constants
	 *           PREC_NONE, PREC_LEFT, PREC_RIGHT, or PREC_BOTH defined
	 *           in sundials_iterative.h.
	 *           These correspond to no preconditioning,
	 *           left preconditioning only, right preconditioning
	 *           only, and both left and right preconditioning,
	 *           respectively.
	 *
	 * maxl      is the maximum Krylov dimension. This is an
	 *           optional input to the CVSPGMR solver. Pass 0 to
	 *           use the default value CVSPGMR_MAXL=5.
	 *
	 * The return value of CVSpgmr is one of:
	 *    CVSPILS_SUCCESS   if successful
	 *    CVSPILS_MEM_NULL  if the cvode memory was NULL
	 *    CVSPILS_MEM_FAIL  if there was a memory allocation failure
	 *    CVSPILS_ILL_INPUT if a required vector operation is missing
	 * The above constants are defined in cvode_spils.h
	 *
 * This routine initializes the memory record and sets various function
 * fields specific to the Spgmr linear solver module. CVSpgmr first
 * calls the existing lfree routine if this is not NULL.  It then sets
 * the cv_linit, cv_lsetup, cv_lsolve, cv_lfree fields in (*cvode_mem)
 * to be CVSpgmrInit, CVSpgmrSetup, CVSpgmrSolve, and CVSpgmrFree,
 * respectively.  It allocates memory for a structure of type
 * CVSpilsMemRec and sets the cv_lmem field in (*cvode_mem) to the
 * address of this structure.  It sets setupNonNull in (*cvode_mem),
 * and sets various fields in the CVSpilsMemRec structure.
 * Finally, CVSpgmr allocates memory for ytemp and x, and calls
 * SpgmrMalloc to allocate memory for the Spgmr solver.
	 */
	public static native int CVSpgmr(Pointer<? > cvode_mem, int pretype, int maxl);

	/**
	 * A call to the CVSptfqmr function links the main CVODE integrator
	 * with the CVSPTFQMR linear solver.
	 *
	 * cvode_mem is the pointer to the integrator memory returned by
	 *           CVodeCreate.
	 *
	 * pretype   is the type of user preconditioning to be done.
	 *           This must be one of the four enumeration constants
	 *           PREC_NONE, PREC_LEFT, PREC_RIGHT, or PREC_BOTH defined
	 *           in iterative.h. These correspond to no preconditioning,
	 *           left preconditioning only, right preconditioning
	 *           only, and both left and right preconditioning,
	 *           respectively.
	 *
	 * maxl      is the maximum Krylov dimension. This is an
	 *           optional input to the CVSPTFQMR solver. Pass 0 to
	 *           use the default value CVSPILS_MAXL=5.
	 *
	 * The return value of CVSptfqmr is one of:
	 *    CVSPILS_SUCCESS   if successful
	 *    CVSPILS_MEM_NULL  if the cvode memory was NULL
	 *    CVSPILS_MEM_FAIL  if there was a memory allocation failure
	 *    CVSPILS_ILL_INPUT if a required vector operation is missing
	 * The above constants are defined in cvode_spils.h

	 * This routine initializes the memory record and sets various function
	 * fields specific to the Sptfqmr linear solver module. CVSptfqmr first
	 * calls the existing lfree routine if this is not NULL. It then sets
	 * the cv_linit, cv_lsetup, cv_lsolve, cv_lfree fields in (*cvode_mem)
	 * to be CVSptfqmrInit, CVSptfqmrSetup, CVSptfqmrSolve, and CVSptfqmrFree,
	 * respectively. It allocates memory for a structure of type
	 * CVSpilsMemRec and sets the cv_lmem field in (*cvode_mem) to the
	 * address of this structure. It sets setupNonNull in (*cvode_mem),
	 * and sets various fields in the CVSpilsMemRec structure.
	 * Finally, CVSptfqmr allocates memory for ytemp and x, and calls
	 * SptfqmrMalloc to allocate memory for the Sptfqmr solver.
	 */
	public static native int CVSptfqmr(Pointer<? > cvode_mem, int pretype, int maxl);

	/// Undefined type
	public static interface FILE {

	};
}
